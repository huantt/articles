{"url":"https://dev.to/jacktt/postgres-multi-version-concurrency-control-24nl","slug":"database-multi-version-concurrency-control","title":"[Database] Multi-Version Concurrency Control","description":"What is Multi-Version Concurrency Control   Multi-Version Concurrency Control (MVCC) is a...","body_markdown":"## What is Multi-Version Concurrency Control\nMulti-Version Concurrency Control (MVCC) is a database management technique that **ensures the consistency and isolation of transactions** in a database while allowing **concurrent access**. \n\nIt addresses the limitations of traditional locking mechanisms, such as pessimistic concurrency control, by enabling multiple versions of data to coexist. This approach enhances system performance and user experience by reducing contention and allowing transactions to proceed without unnecessary waiting.\n\n## How MVCC works\n\nMVCC maintains multiple versions of each database item. \n\nWhen a transaction updates a data item, a new version of the item is created rather than overwriting the existing one. This allows read operations to access older versions of the data without waiting for the write operations to complete the new version.\n\nHere's a simplified breakdown of how MVCC operates:\n\n**1/ Read Operations:** When a transaction reads a data item, it retrieves the version of the item that was most recently committed before the transaction began. This guarantees a consistent view of the database without interference from other transactions.\n\n**2. Write Operations:** When a transaction writes or updates a data item, it creates a new version. This new version is not visible to other transactions until the writing transaction commits, ensuring that no other transaction reads uncommitted changes (thus avoiding dirty reads).\n\n**3/ Commit and Cleanup:** When a transaction commits, its changes become visible to other transactions. Older versions of data that are no longer needed (because no active transaction requires them) are eventually cleaned up, freeing up space and resources.\n\n## Example\nLet's consider the following scenario:\nGiven a product that has max quantity of 10.\n\n\n![Image description](https://i.imgur.com/5cG4dWc.png)\n\n\n\nAt the same time, we have 2 concurrent transactions:\n- 1. Count sales and get remaining items\n- 2. Insert new sale and decrease remaining items\n\n\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mslxh15jtpwqxg4fopea.png)\n\n\n**Without MVCC and any locking mechanism**:\n- While the first transaction is counting, it also counts the row inserted by the second transaction. The total count will be 4. \n- When getting the remaining product, because the second transaction has not finished the update, the first transaction will get 7 as the remaining quantity. \n- So, the total is 11. This number is incorrect because it counted the new sale but read the old remaining quantity.\n\n**With MVCC:**\n- Before starting the count, the first transaction uses M as the version for the related sales rows and N as the version for the product row. \n- In these version:\n  + The related sales rows include only Row A, Row B, and Row C. Row D is not included, even though it was inserted in the second transaction (but has not been committed).\n  + The product row has a remaining quantity of 6.\n- Therefore, the result will be 3 for the count query and 7 for the remaining quantity. This is correct and consistent.\n\n\n## References\nAccording to this video, Postgres uses timestamp as version number for rows. \n\nhttps://www.youtube.com/watch?v=ZxhBkBNxvR0\u0026t=1107s\n\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/2u11jk4hrxoklnx2xpu2.png)\n\n","body_html":"\u003ch2\u003e\n  \u003ca name=\"what-is-multiversion-concurrency-control\" href=\"#what-is-multiversion-concurrency-control\"\u003e\n  \u003c/a\u003e\n  What is Multi-Version Concurrency Control\n\u003c/h2\u003e\n\n\u003cp\u003eMulti-Version Concurrency Control (MVCC) is a database management technique that \u003cstrong\u003eensures the consistency and isolation of transactions\u003c/strong\u003e in a database while allowing \u003cstrong\u003econcurrent access\u003c/strong\u003e. \u003c/p\u003e\n\n\u003cp\u003eIt addresses the limitations of traditional locking mechanisms, such as pessimistic concurrency control, by enabling multiple versions of data to coexist. This approach enhances system performance and user experience by reducing contention and allowing transactions to proceed without unnecessary waiting.\u003c/p\u003e\n\n\u003ch2\u003e\n  \u003ca name=\"how-mvcc-works\" href=\"#how-mvcc-works\"\u003e\n  \u003c/a\u003e\n  How MVCC works\n\u003c/h2\u003e\n\n\u003cp\u003eMVCC maintains multiple versions of each database item. \u003c/p\u003e\n\n\u003cp\u003eWhen a transaction updates a data item, a new version of the item is created rather than overwriting the existing one. This allows read operations to access older versions of the data without waiting for the write operations to complete the new version.\u003c/p\u003e\n\n\u003cp\u003eHere's a simplified breakdown of how MVCC operates:\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e1/ Read Operations:\u003c/strong\u003e When a transaction reads a data item, it retrieves the version of the item that was most recently committed before the transaction began. This guarantees a consistent view of the database without interference from other transactions.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e2. Write Operations:\u003c/strong\u003e When a transaction writes or updates a data item, it creates a new version. This new version is not visible to other transactions until the writing transaction commits, ensuring that no other transaction reads uncommitted changes (thus avoiding dirty reads).\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e3/ Commit and Cleanup:\u003c/strong\u003e When a transaction commits, its changes become visible to other transactions. Older versions of data that are no longer needed (because no active transaction requires them) are eventually cleaned up, freeing up space and resources.\u003c/p\u003e\n\n\u003ch2\u003e\n  \u003ca name=\"example\" href=\"#example\"\u003e\n  \u003c/a\u003e\n  Example\n\u003c/h2\u003e\n\n\u003cp\u003eLet's consider the following scenario:\u003cbr\u003e\nGiven a product that has max quantity of 10.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://res.cloudinary.com/practicaldev/image/fetch/s--poNf_7AF--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://i.imgur.com/5cG4dWc.png\" class=\"article-body-image-wrapper\"\u003e\u003cimg src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--poNf_7AF--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://i.imgur.com/5cG4dWc.png\" alt=\"Image description\" loading=\"lazy\" width=\"800\" height=\"505\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eAt the same time, we have 2 concurrent transactions:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e1. Count sales and get remaining items\u003c/li\u003e\n\u003cli\u003e2. Insert new sale and decrease remaining items\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ca href=\"https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fmslxh15jtpwqxg4fopea.png\" class=\"article-body-image-wrapper\"\u003e\u003cimg src=\"https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fmslxh15jtpwqxg4fopea.png\" alt=\"Image description\" loading=\"lazy\" width=\"800\" height=\"99\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eWithout MVCC and any locking mechanism\u003c/strong\u003e:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eWhile the first transaction is counting, it also counts the row inserted by the second transaction. The total count will be 4. \u003c/li\u003e\n\u003cli\u003eWhen getting the remaining product, because the second transaction has not finished the update, the first transaction will get 7 as the remaining quantity. \u003c/li\u003e\n\u003cli\u003eSo, the total is 11. This number is incorrect because it counted the new sale but read the old remaining quantity.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003eWith MVCC:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eBefore starting the count, the first transaction uses M as the version for the related sales rows and N as the version for the product row. \u003c/li\u003e\n\u003cli\u003eIn these version:\n\n\u003cul\u003e\n\u003cli\u003eThe related sales rows include only Row A, Row B, and Row C. Row D is not included, even though it was inserted in the second transaction (but has not been committed).\u003c/li\u003e\n\u003cli\u003eThe product row has a remaining quantity of 6.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003c/li\u003e\n\n\u003cli\u003eTherefore, the result will be 3 for the count query and 7 for the remaining quantity. This is correct and consistent.\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch2\u003e\n  \u003ca name=\"references\" href=\"#references\"\u003e\n  \u003c/a\u003e\n  References\n\u003c/h2\u003e\n\n\u003cp\u003eAccording to this video, Postgres uses timestamp as version number for rows. \u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=ZxhBkBNxvR0\u0026amp;t=1107s\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://www.youtube.com/watch?v=ZxhBkBNxvR0\u0026amp;t=1107s\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F2u11jk4hrxoklnx2xpu2.png\" class=\"article-body-image-wrapper\"\u003e\u003cimg src=\"https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F2u11jk4hrxoklnx2xpu2.png\" alt=\"Image description\" loading=\"lazy\" width=\"800\" height=\"603\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n","thumbnail":"https://media.dev.to/cdn-cgi/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7vnbivhqy7dwemno0kmh.png","author":{"id":"jacktt","name":"JackTT"},"created_at":"2024-09-03T06:34:36Z","updated_at":null,"tags":[]}