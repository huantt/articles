{"url":"https://dev.to/jacktt/postgres-isolation-levels-72h","slug":"postgres-isolation-levels","title":"[Postgres] Isolation levels","description":"In PostgreSQL, isolation levels determine how transaction integrity is maintained when multiple...","body_markdown":"In PostgreSQL, **isolation levels** determine how transaction integrity is maintained when multiple transactions occur concurrently. \n\nThese levels control the visibility of changes made by other transactions and help prevent phenomena like dirty reads, non-repeatable reads, and phantom reads. \n\n## Why Isolation Levels Matter\n- **Data Consistency**: Incorrect isolation levels can lead to inconsistent data states, such as dirty reads, lost updates, and phantom reads.\n- **Performance**: Higher isolation levels often require more locking, which can impact performance.\n- **Concurrency**: Lower isolation levels allow for greater concurrency but may introduce risks.\n\n## Read Phenomena\nSome isolation levels may encounter the following read phenomena. \nUnderstanding each of them and how to prevent them by using the appropriate isolation level is the purpose of this article.\n\n- **Dirty Read**: Reading uncommitted changes from another transaction. *** (It's prevented in Postgres due to MVCC model)***\n- **Non-repeatable Read**: The result of the same query within a transaction may vary due to changes made by other transactions that have been committed.\n- **Phantom Read**: New rows are apeared or disapeard from a query result between 2 executions due to changes made by another transaction that is committed in between.\n\n## Isolation levels\nThe following isolation level is sorted from lowest to higest:\n\n### 1. **Read Uncommitted**\n- In this level, a transaction can read uncommitted changes made by other transactions. However, PostgreSQL internally treats this level as **Read Committed**, meaning it does not allow dirty reads.\n- **Phenomena**: Dirty reads are prevented in PostgreSQL, but non-repeatable reads and phantom reads may still occur.\n\n### 2. **Read Committed**\n- This is the default isolation level in PostgreSQL. \n- A transaction sees only the committed data at the start of each query within the transaction. It can’t see uncommitted changes from other transactions.\n- **Phenomena**: Non-repeatable reads and phantom reads are possible, but dirty reads are prevented.\n\n*Worth noting that we're mentioning the **\"at the start of each query winthin transaction\",** not the **\"at the start of transaction\"***.\n\n### 3. **Repeatable Read**\n- A transaction in this isolation level sees a consistent snapshot of the database taken when the transaction starts. No other transaction's changes are visible during the transaction, even if they commit.\n- **Phenomena**: Prevents both dirty and non-repeatable reads, but phantom reads can still happen.\n\n### 4. **Serializable**\n- This is the strictest isolation level. It ensures that transactions execute in such a way that the outcome is as if they were executed one after the other, rather than concurrently. It effectively prevents all three phenomena (dirty reads, non-repeatable reads, and phantom reads).\n- **Phenomena**: Prevents dirty reads, non-repeatable reads, and phantom reads, ensuring full transaction isolation.\n","body_html":"\u003cp\u003eIn PostgreSQL, \u003cstrong\u003eisolation levels\u003c/strong\u003e determine how transaction integrity is maintained when multiple transactions occur concurrently. \u003c/p\u003e\n\n\u003cp\u003eThese levels control the visibility of changes made by other transactions and help prevent phenomena like dirty reads, non-repeatable reads, and phantom reads. \u003c/p\u003e\n\n\u003ch2\u003e\n  \u003ca name=\"why-isolation-levels-matter\" href=\"#why-isolation-levels-matter\"\u003e\n  \u003c/a\u003e\n  Why Isolation Levels Matter\n\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003cstrong\u003eData Consistency\u003c/strong\u003e: Incorrect isolation levels can lead to inconsistent data states, such as dirty reads, lost updates, and phantom reads.\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003ePerformance\u003c/strong\u003e: Higher isolation levels often require more locking, which can impact performance.\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003eConcurrency\u003c/strong\u003e: Lower isolation levels allow for greater concurrency but may introduce risks.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e\n  \u003ca name=\"read-phenomena\" href=\"#read-phenomena\"\u003e\n  \u003c/a\u003e\n  Read Phenomena\n\u003c/h2\u003e\n\n\u003cp\u003eSome isolation levels may encounter the following read phenomena. \u003cbr\u003e\nUnderstanding each of them and how to prevent them by using the appropriate isolation level is the purpose of this article.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003cstrong\u003eDirty Read\u003c/strong\u003e: Reading uncommitted changes from another transaction. *** (It's prevented in Postgres due to MVCC model)***\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003eNon-repeatable Read\u003c/strong\u003e: The result of the same query within a transaction may vary due to changes made by other transactions that have been committed.\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003ePhantom Read\u003c/strong\u003e: New rows are apeared or disapeard from a query result between 2 executions due to changes made by another transaction that is committed in between.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e\n  \u003ca name=\"isolation-levels\" href=\"#isolation-levels\"\u003e\n  \u003c/a\u003e\n  Isolation levels\n\u003c/h2\u003e\n\n\u003cp\u003eThe following isolation level is sorted from lowest to higest:\u003c/p\u003e\n\n\u003ch3\u003e\n  \u003ca name=\"1-read-uncommitted\" href=\"#1-read-uncommitted\"\u003e\n  \u003c/a\u003e\n  1. \u003cstrong\u003eRead Uncommitted\u003c/strong\u003e\n\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eIn this level, a transaction can read uncommitted changes made by other transactions. However, PostgreSQL internally treats this level as \u003cstrong\u003eRead Committed\u003c/strong\u003e, meaning it does not allow dirty reads.\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003ePhenomena\u003c/strong\u003e: Dirty reads are prevented in PostgreSQL, but non-repeatable reads and phantom reads may still occur.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003e\n  \u003ca name=\"2-read-committed\" href=\"#2-read-committed\"\u003e\n  \u003c/a\u003e\n  2. \u003cstrong\u003eRead Committed\u003c/strong\u003e\n\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eThis is the default isolation level in PostgreSQL. \u003c/li\u003e\n\u003cli\u003eA transaction sees only the committed data at the start of each query within the transaction. It can’t see uncommitted changes from other transactions.\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003ePhenomena\u003c/strong\u003e: Non-repeatable reads and phantom reads are possible, but dirty reads are prevented.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cem\u003eWorth noting that we're mentioning the *\u003c/em\u003e\"at the start of each query winthin transaction\",** not the \u003cstrong\u003e\"at the start of transaction\"\u003c/strong\u003e*.\u003c/p\u003e\n\n\u003ch3\u003e\n  \u003ca name=\"3-repeatable-read\" href=\"#3-repeatable-read\"\u003e\n  \u003c/a\u003e\n  3. \u003cstrong\u003eRepeatable Read\u003c/strong\u003e\n\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eA transaction in this isolation level sees a consistent snapshot of the database taken when the transaction starts. No other transaction's changes are visible during the transaction, even if they commit.\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003ePhenomena\u003c/strong\u003e: Prevents both dirty and non-repeatable reads, but phantom reads can still happen.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003e\n  \u003ca name=\"4-serializable\" href=\"#4-serializable\"\u003e\n  \u003c/a\u003e\n  4. \u003cstrong\u003eSerializable\u003c/strong\u003e\n\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eThis is the strictest isolation level. It ensures that transactions execute in such a way that the outcome is as if they were executed one after the other, rather than concurrently. It effectively prevents all three phenomena (dirty reads, non-repeatable reads, and phantom reads).\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003ePhenomena\u003c/strong\u003e: Prevents dirty reads, non-repeatable reads, and phantom reads, ensuring full transaction isolation.\u003c/li\u003e\n\u003c/ul\u003e\n\n","thumbnail":"","author":{"id":"jacktt","name":"JackTT"},"created_at":"2024-09-12T01:33:34Z","updated_at":null,"tags":[]}